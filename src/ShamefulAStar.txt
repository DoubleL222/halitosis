//struct AStarNode {
//	float f_val; //F is the total cost of the node. f = g + h
//	float h_val; //G is the distance between the current node and the start node.
//	float g_val; //H is the heuristic estimated distance from the current node to the end node.
//
//	float movement_penalty; //weight
//
//	AStarNode * parent = nullptr;
//	hlt::Position node_position;
//
//	AStarNode(hlt::Position pos) : node_position(pos)
//	{};
//
//	bool operator ==(const AStarNode& a) const
//	{
//		return node_position == a.node_position;
//	}
//};

//Path Frame::get_a_star_path(hlt::GameMap & map, hlt::Position from, hlt::Position end)
//{
//	// Put node_start in the OPEN list 
//	//WARNING -> SHOULD NEVER POINT TO VECTOR ELEMENTS
//	AStarNode* current_node = new AStarNode(from);
//	current_node->h_val = map.calculate_distance(from, end);
//	current_node->g_val = 0;
//	current_node->movement_penalty = 0;
//	//WARNING -> SHOULD NEVER POINT TO VECTOR ELEMENTS
//	AStarNode* end_node = new AStarNode(end);
//
//	std::vector<AStarNode> open_list;
//	std::vector<AStarNode> closed_list;
//	open_list.push_back(*current_node);
//	//while the OPEN list is not empty
//	while (open_list.size() > 0) 
//	{
//		//Take from the open list the node node_current with the lowest f(node_current) = g(node_current) + h(node_current)
//		float lowest_f = std::numeric_limits<float>::max();
//
//		//WARNING -> SHOULD NEVER POINT TO VECTOR ELEMENTS
//		AStarNode * lowest_node = nullptr;
//		for (int i = 0; i< open_list.size(); i++)
//		{
//			float current_f = open_list[i].g_val + open_list[i].h_val;
//			if (current_f < lowest_f)
//			{
//				lowest_f = current_f;
//				lowest_node = &open_list[i];
//			}
//		}
//		/*for (AStarNode node : open_list) 
//		{
//			float current_f = node.g_val + node.h_val;
//			if (current_f < lowest_f) 
//			{
//				lowest_f = current_f;
//				lowest_node = &node;
//			}
//		}*/
//		current_node = lowest_node;
//
//		if (current_node->node_position == end_node->node_position) 
//		{
//			//TODO return path
//			break;
//		}
//
//		//Generate each state node_successor that come after node_current
//		std::array<hlt::Position, 4U> neighbours = current_node->node_position.get_surrounding_cardinals();
//		//for each node_successor of node_current
//		for (hlt::Position neighbour_position : neighbours) 
//		{
//			//Set successor_current_cost = g(node_current) + w(node_current, node_successor)
//			float neighbour_current_cost = current_node->g_val + map.calculate_distance(current_node->node_position, neighbour_position);
//			
//			//check if in open or closed list
//			bool is_in_open_list = false;
//			bool is_in_closed_list = false;
//			int open_list_id = -1;
//			int closed_list_id = -1;
//			if (open_list.size() > 0) 
//			{
//				for (int i = 0; i < open_list.size(); i++)
//				{
//					if (open_list[i].node_position == neighbour_position)
//					{
//						is_in_open_list = true;
//						open_list_id = i;
//					}
//				}
//			}
//			if (!is_in_open_list && closed_list.size() > 0) 
//			{
//				for (int i = 0; i < closed_list.size(); i++)
//				{
//					if (closed_list[i].node_position == neighbour_position)
//					{
//						is_in_closed_list = true;
//						closed_list_id = i;
//					}
//				}
//			}
//
//			AStarNode * selected_neighbour_node = nullptr;
//			//if node_successor is in the OPEN list, if g(node_successor) ≤ successor_current_cost continue
//			if (is_in_open_list) 
//			{
//				if (open_list[open_list_id].g_val <= neighbour_current_cost) 
//				{
//					continue;
//				}
//				selected_neighbour_node = &open_list[open_list_id];
//			}
//			//else if node_successor is in the CLOSED list, if g(node_successor) ≤ successor_current_cost continue
//			else if (is_in_closed_list) 
//			{
//				if (closed_list[closed_list_id].g_val <= neighbour_current_cost)
//				{
//					continue;
//				}
//				//Move node_successor from the CLOSED list to the OPEN list
//				open_list.push_back(closed_list[closed_list_id]);
//				selected_neighbour_node = &open_list[open_list.size() - 1];
//				closed_list.erase(closed_list.begin()+closed_list_id);
//			}
//			//else Add node_successor to the OPEN list, Set h(node_successor) to be the heuristic distance to node_goal
//			else
//			{
//				selected_neighbour_node = new AStarNode(neighbour_position);
//				selected_neighbour_node->h_val = map.calculate_distance(neighbour_position, end);
//				selected_neighbour_node->g_val = 0;
//				selected_neighbour_node->movement_penalty = 0;
//				open_list.push_back(*selected_neighbour_node);
//			}
//			//Set g(node_successor) = successor_current_cost, Set the parent of node_successor to node_current
//			selected_neighbour_node->g_val = neighbour_current_cost;
//			selected_neighbour_node->parent = current_node;
//		}
//		closed_list.push_back(*current_node);
//		//vec.erase(std::remove(vec.begin(), vec.end(), 8), vec.end());
//		open_list.erase(std::remove(open_list.begin(), open_list.end(), *current_node), open_list.end());
//
//		//TODO remove node from open
//		//if(open)
//	}
//
//	return Path();
//}